{"version":3,"sources":["components/Node/Node.jsx","utils/animation.js","algorithms/dijkstra.js","algorithms/stack.js","algorithms/DFS.js","algorithms/queue.js","algorithms/BFS.js","algorithms/A-star.js","utils/constants.js","factory/GridFactory.jsx","components/Grid.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseLeave","extraClassName","id","className","Animation","visitedNodesInOrder","nodesInShortestPathOrder","i","length","setTimeout","animateShortestPath","node","document","getElementById","visualizeDijkstra","grid","startNode","finishNode","startNodeVisualization","finishNodeVisualization","distance","unvisitedNodes","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","isVisited","push","updateUnvisitedNeighbors","dijkstra","currentNode","unshift","previousNode","getNodesInShortestPathOrder","animateAlgorithm","nodes","sort","nodeA","nodeB","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","neighbors","filter","Stack","this","items","element","pop","visualizeDFS","stack","size","top","adjacent","DFS","newnodes","Queue","visualizeBFS","queue","BFS","visualizeAstar","AStar","distanceToFinishNode","Constants","ROWS_NUMBER","COLUMNS_NUMBER","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","GridFactory","getInitialGrid","currentRow","createNode","clearGrid","getNewGridWithWallToggled","newGrid","slice","newNode","getNewGridWithStarNode","leaveTheNode","getNewGridWithFinishNode","Math","abs","Grid","useState","isMoving","setStartNode","setFinishNode","isMousePressed","setIsMousePressed","setGrid","randomNumber","mx","mn","floor","random","onClick","initial","end","j","generateRandomMaze","onMouseUp","map","rowIdx","nodeIdx","mouseIsPressed","nodeClicked","handleMouseDown","handleMouseEnter","handleMouseLeave","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.6afbae70.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nconst Node = ({row, col, isFinish, isStart, isWall, onMouseDown, onMouseEnter, onMouseLeave}) => {\r\n  const extraClassName = isFinish\r\n    ? \"node-finish\"\r\n    : isStart\r\n    ? \"node-start\"\r\n    : isWall\r\n    ? \"node-wall\"\r\n    : \"\";\r\n\r\n  return (\r\n    <div\r\n      id={`node-${row}-${col}`}\r\n      className={`node ${extraClassName}`}\r\n      onMouseDown={() => onMouseDown(row, col)}\r\n      onMouseEnter={() => onMouseEnter(row, col)}\r\n      onMouseLeave={() => onMouseLeave(row, col)}\r\n    ></div>\r\n  );\r\n};\r\n\r\nexport default Node;","export default class Animation{\r\n\r\n    static animateAlgorithm  (visitedNodesInOrder, nodesInShortestPathOrder) {\r\n       for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n         if (i === visitedNodesInOrder.length) {\r\n           setTimeout(() => {\r\n             this.animateShortestPath(nodesInShortestPathOrder);\r\n           }, 10 * i);\r\n           return;\r\n         }\r\n         setTimeout(() => {\r\n           const node = visitedNodesInOrder[i];\r\n           document.getElementById(`node-${node.row}-${node.col}`).className =\r\n             'node node-visited';\r\n         }, 10 * i);\r\n       }\r\n     }\r\n   \r\n     static animateShortestPath (nodesInShortestPathOrder) {\r\n       for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n         setTimeout(() => {\r\n           const node = nodesInShortestPathOrder[i];\r\n           document.getElementById(`node-${node.row}-${node.col}`).className =\r\n             'node node-shortest-path';\r\n         }, 50 * i);\r\n       }\r\n     }\r\n    }","//In Dijkstra Algorithm we start with our node and relax all the node connected by it only \r\n// if d[u]+w<d[v] (w->v path) and greedle chooses next min distance node available to user\r\n// and follow the same recursivly thus this is a greedy approach. \r\n\r\n//in shortest path we will keep track of the previous node of all the nodes in shortest path \r\n//so as to back track it\r\nimport Animation from \"../utils/animation.js\";\r\nexport function visualizeDijkstra(grid, startNode, finishNode) {\r\n  const startNodeVisualization = grid[startNode.row][startNode.col];\r\n  const finishNodeVisualization = grid[finishNode.row][finishNode.col];\r\n  const visitedNodesInOrder = dijkstra(\r\n    grid,\r\n    startNodeVisualization,\r\n    finishNodeVisualization\r\n  );\r\n\r\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(\r\n    finishNodeVisualization\r\n  );\r\n\r\n  Animation.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n}\r\n\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    //priority queue can be used for optimizatin since we are sorting all node by distance and picking up the least,\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();//removes the 1st element\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    //push that least node in our animated path\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  } return visitedNodesInOrder;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\nconst getAllNodes = (grid) => {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n};\r\n\r\nconst sortNodesByDistance = (unvisitedNodes) => {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n};\r\n\r\nconst updateUnvisitedNeighbors = (node, grid) => {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n};\r\n\r\nconst getUnvisitedNeighbors = (node, grid) => {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n};","\r\nclass Stack {\r\n    constructor() {\r\n        this.items = [];\r\n    }\r\n\r\n    push(element) {\r\n        this.items.push(element);\r\n    }\r\n\r\n    pop() {\r\n        return this.items.pop();\r\n    }\r\n\r\n    peek() {\r\n        return this.items[this.items.length - 1];\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.items.length === 0;\r\n    }\r\n\r\n    size() {\r\n        return this.items.length;\r\n    }\r\n\r\n    clear() {\r\n        this.items = [];\r\n    }\r\n\r\n}\r\nexport default Stack;","\r\nimport Animation from \"../utils/animation.js\";\r\nimport Stack from \"../algorithms/stack.js\";\r\nexport function visualizeDFS(grid, startNode, finishNode) {\r\n  const startNodeVisualization = grid[startNode.row][startNode.col];\r\n  const finishNodeVisualization = grid[finishNode.row][finishNode.col];\r\n  const visitedNodesInOrder = DFS(\r\n    grid,\r\n    startNodeVisualization,\r\n    finishNodeVisualization\r\n  );\r\n\r\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(\r\n    finishNodeVisualization\r\n  );\r\n\r\n  Animation.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\nexport function DFS(grid, startNode, finishNode) {\r\n   const stack=new Stack();\r\n   const visitedNodesInOrder = [];\r\n   stack.push(startNode);\r\n   while(!!stack.size())\r\n   {\r\n     const top=stack.pop();\r\n     if(top==finishNode) return visitedNodesInOrder;\r\n     if (!top.isWall && (top.isStart || !top.isVisited) ) {\r\n      top.isVisited = true;\r\n      visitedNodesInOrder.push(top);\r\n     const adjacent=updateUnvisitedNeighbors(top,grid);\r\n     for (const node of adjacent)\r\n     {\r\n      stack.push(node);\r\n     }\r\n    }\r\n  }\r\n\r\n   \r\n   return visitedNodesInOrder;\r\n}\r\n\r\nconst updateUnvisitedNeighbors = (node, grid) => {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  const newnodes = []\r\n  for (const neighbor of unvisitedNeighbors) {\r\n       neighbor.previousNode = node;\r\n       newnodes.push(neighbor)\r\n  }\r\n  return newnodes;\r\n};\r\n\r\nconst getUnvisitedNeighbors = (node, grid) => {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n};","\r\nclass Queue {\r\n    constructor() {\r\n        this.items = [];\r\n    }\r\n\r\n    push(element) {\r\n        this.items.push(element);\r\n    }\r\n\r\n    pop() {\r\n        return this.items.shift();\r\n    }\r\n\r\n    peek() {\r\n        return this.items[this.items.length - 1];\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.items.length === 0;\r\n    }\r\n\r\n    size() {\r\n        return this.items.length;\r\n    }\r\n\r\n    clear() {\r\n        this.items = [];\r\n    }\r\n\r\n}\r\nexport default Queue;","\r\nimport Animation from \"../utils/animation.js\";\r\nimport Queue from \"../algorithms/queue.js\";\r\nexport function visualizeBFS(grid, startNode, finishNode) {\r\n  const startNodeVisualization = grid[startNode.row][startNode.col];\r\n  const finishNodeVisualization = grid[finishNode.row][finishNode.col];\r\n  const visitedNodesInOrder = BFS(\r\n    grid,\r\n    startNodeVisualization,\r\n    finishNodeVisualization\r\n  );\r\n\r\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(\r\n    finishNodeVisualization\r\n  );\r\n\r\n  Animation.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n}\r\n\r\n function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n function BFS(grid, startNode, finishNode) {\r\n   const queue=new Queue();\r\n   const visitedNodesInOrder = [];\r\n   queue.push(startNode);\r\n   while(!!queue.size())\r\n   {\r\n     const top=queue.pop();\r\n     if(top==finishNode) return visitedNodesInOrder;\r\n     if (!top.isWall && (top.isStart || !top.isVisited) ) {\r\n      top.isVisited = true;\r\n      visitedNodesInOrder.push(top);\r\n     const adjacent=updateUnvisitedNeighbors(top,grid);\r\n     for (const node of adjacent)\r\n     {\r\n      queue.push(node);\r\n     }\r\n    }\r\n  }\r\n\r\n   \r\n   return visitedNodesInOrder;\r\n}\r\n\r\nconst updateUnvisitedNeighbors = (node, grid) => {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  const newnodes = []\r\n  for (const neighbor of unvisitedNeighbors) {\r\n       neighbor.previousNode = node;\r\n       newnodes.push(neighbor)\r\n  }\r\n  return newnodes;\r\n};\r\n\r\nconst getUnvisitedNeighbors = (node, grid) => {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n};","\r\nimport Animation from \"../utils/animation.js\";\r\nexport function visualizeAstar(grid, startNode, finishNode) {\r\n    const startNodeVisualization = grid[startNode.row][startNode.col];\r\n    const finishNodeVisualization = grid[finishNode.row][finishNode.col];\r\n    const visitedNodesInOrder = AStar(\r\n      grid,\r\n      startNodeVisualization,\r\n      finishNodeVisualization\r\n    );\r\n  \r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(\r\n      finishNodeVisualization\r\n    );\r\n  \r\n    Animation.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n\r\nexport function AStar(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    //priority queue can be used for optimizatin since we are sorting all node by distance and picking up the least,\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();//removes the 1st element\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    //push that least node in our animated path\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  } return visitedNodesInOrder;\r\n  }\r\n\r\n  export function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n  \r\n  \r\n  const getAllNodes = (grid) => {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  };\r\n  \r\n  const sortNodesByDistance = (unvisitedNodes) => {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  };\r\n  \r\n\r\n  const updateUnvisitedNeighbors = (node, grid) => {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\r\n      neighbor.previousNode = node;\r\n    }\r\n  };\r\n  const getUnvisitedNeighbors = (node, grid) => {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n  };","export default class Constants {\r\n    static ROWS_NUMBER = 28;\r\n    static COLUMNS_NUMBER = 72;\r\n  \r\n    static START_NODE_ROW = 10;\r\n    static START_NODE_COL = 15;\r\n    static FINISH_NODE_ROW = 11;\r\n    static FINISH_NODE_COL = 35;\r\n  }","import Constants from \"../utils/constants\";\r\nimport React, { Fragment, useState } from \"react\";\r\nexport default class GridFactory {\r\n  \r\n\r\n\r\n  static getInitialGrid = (startNode, finishNode) => {\r\n    const grid = [];\r\n    for (let row = 0; row < Constants.ROWS_NUMBER; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < Constants.COLUMNS_NUMBER; col++) {\r\n        currentRow.push(this.createNode(col, row, startNode, finishNode));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    //grid=clearGrid(grid,startNode,finishNode);\r\n    return grid;\r\n  };\r\n\r\n  static clearGrid = (startNode, finishNode) => {\r\n    \r\n    const grid = [];\r\n    \r\n    for (let row = 0; row < Constants.ROWS_NUMBER; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < Constants.COLUMNS_NUMBER; col++) {\r\n        currentRow.push(this.createNode(col, row, startNode, finishNode));\r\n        if (col === startNode.col && row === startNode.row) {\r\n          document.getElementById(`node-${row}-${col}`).className =\r\n            \"node node-start\";\r\n        } else if (col === finishNode.col && row === finishNode.row) {\r\n          document.getElementById(`node-${row}-${col}`).className =\r\n            \"node node-finish\";\r\n        } else {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  \r\n\r\n\r\n\r\n  static getNewGridWithWallToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n      \r\n    const newNode = {\r\n      ...node,\r\n      isWall: 1,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  static getNewGridWithStarNode = (grid, row, col, leaveTheNode) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isStart: !leaveTheNode,\r\n      isWall: false,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  static getNewGridWithFinishNode = (grid, row, col, leaveTheNode) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isFinish: !leaveTheNode,\r\n      isWall: false,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n  static createNode = (col, row, startNode, finishNode) => {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row === startNode.row && col === startNode.col,\r\n      isFinish: row === finishNode.row && col === finishNode.col,\r\n      distance: Infinity,  //manhattanDistance of final and current node\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      distanceToFinishNode:Math.abs(finishNode.row - row)+ Math.abs(finishNode.col - col),\r\n    };\r\n  };\r\n}","import React, { Fragment, useState } from \"react\";\r\nimport Node from \"./Node/Node\";\r\n\r\n\r\nimport { visualizeDijkstra } from \"../algorithms/dijkstra\";\r\nimport { visualizeDFS } from \"../algorithms/DFS\";\r\nimport { visualizeBFS } from \"../algorithms/BFS\";\r\nimport { visualizeAstar } from \"../algorithms/A-star\";\r\nimport Navbar from \"./Layout/Navbar\";\r\nimport GridFactory from \"../factory/GridFactory\";\r\nimport Constants from \"../utils/constants\";\r\n\r\nimport \"./Grid.css\";\r\n\r\nconst Grid = () => {\r\n  const [startNode, setStartNode] = useState({\r\n    row: Constants.START_NODE_ROW,\r\n    col: Constants.START_NODE_COL,\r\n    isMoving: false,\r\n  });\r\n  const [finishNode, setFinishNode] = useState({\r\n    row: Constants.FINISH_NODE_ROW,\r\n    col: Constants.FINISH_NODE_COL,\r\n    isMoving: false,\r\n  });\r\n\r\n  const [isMousePressed, setIsMousePressed] = useState(false);\r\n\r\n  const [grid, setGrid] = useState(\r\n    GridFactory.getInitialGrid(startNode, finishNode)\r\n  );\r\n\r\n  const randomNumber = (mx, mn) =>\r\n  {\r\n    return Math.floor(Math.random() * (mx - mn +1) ) + mn;\r\n  }\r\n\r\n   const generateRandomMaze =(startNode, finishNode) => {\r\n     \r\n    for(var i=1;i<Constants.ROWS_NUMBER;i++)\r\n  {\r\n      if(i%2==0)\r\n      {\r\n          const initial=randomNumber(Constants.COLUMNS_NUMBER-1,1);\r\n          const end=randomNumber(Constants.COLUMNS_NUMBER-1,initial);\r\n          for(var j=initial;j<=end;j++)\r\n          { if(i===startNode.row && j==startNode.col) continue;\r\n            if(i===finishNode.row && j==finishNode.col) continue;\r\n            const newGrid = GridFactory.getNewGridWithWallToggled(grid, i, j);\r\n            setGrid(newGrid);\r\n                    }\r\n      }\r\n\r\n      \r\n  }\r\n\r\n  for(var i=1;i<Constants.COLUMNS_NUMBER;i++)\r\n  {\r\n      if(i%2==0)\r\n      {\r\n        const initial=randomNumber(Constants.ROWS_NUMBER-1,1);\r\n        const end=randomNumber(Constants.ROWS_NUMBER-1,initial);\r\n        for(var j=initial;j<=end;j++)\r\n        { if(j===startNode.row && i==startNode.col) continue;\r\n          if(j===finishNode.row && i==finishNode.col) continue;\r\n          const newGrid = GridFactory.getNewGridWithWallToggled(grid, j, i);\r\n          setGrid(newGrid);\r\n         \r\n        }\r\n\r\n      }\r\n  }\r\n\r\n  };\r\n\r\n\r\n  \r\n  const handleMouseDown = (row, col) => {\r\n    setIsMousePressed(true);\r\n    let nodeClicked = grid[row][col];\r\n    if (nodeClicked.isStart) {\r\n      setStartNode({ ...startNode, isMoving: true });\r\n    } else if (nodeClicked.isFinish) {\r\n      setFinishNode({ ...finishNode, isMoving: true });\r\n    } else {\r\n      const newGrid = GridFactory.getNewGridWithWallToggled(grid, row, col);\r\n      setGrid(newGrid);\r\n    }\r\n  };\r\n\r\n  const handleMouseEnter = (row, col) => {\r\n    if (!isMousePressed) return;\r\n    if (startNode.isMoving) {\r\n      setGrid(GridFactory.getNewGridWithStarNode(grid, row, col, false));\r\n      setStartNode({ ...startNode, row, col });\r\n    } else if (finishNode.isMoving) {\r\n      setGrid(GridFactory.getNewGridWithFinishNode(grid, row, col, false));\r\n      setFinishNode({ ...finishNode, row, col });\r\n    } else {\r\n      setGrid(GridFactory.getNewGridWithWallToggled(grid, row, col));\r\n    }\r\n  };\r\n\r\n  const handleMouseLeave = (row, col) => {\r\n    if (!isMousePressed) return;\r\n    let newGrid;\r\n    if (startNode.isMoving) {\r\n      newGrid = GridFactory.getNewGridWithStarNode(grid, row, col, true);\r\n      setGrid(newGrid);\r\n    } else if (finishNode.isMoving) {\r\n      newGrid = GridFactory.getNewGridWithFinishNode(\r\n        grid,\r\n        row,\r\n        col,\r\n        true\r\n      );\r\n      setGrid(newGrid);\r\n    }\r\n  };\r\n\r\n  const handleMouseUp = () => {\r\n    setIsMousePressed(false);\r\n    setStartNode({ ...startNode, isMoving: false });\r\n    setFinishNode({ ...finishNode, isMoving: false });\r\n  };\r\n\r\n  return (\r\n    <Fragment>\r\n        <button className=\"top-buttons\" onClick={() => visualizeDijkstra(grid, startNode, finishNode)}>\r\n          Visualize Dijkstra's Algorithm\r\n        </button>\r\n        <button className=\"top-buttons\" onClick={() => visualizeBFS(grid, startNode, finishNode)}>\r\n          Visualize BFS Algorithm\r\n        </button>\r\n        <button className=\"top-buttons\" onClick={() => visualizeDFS(grid, startNode, finishNode)}>\r\n          Visualize DFS Algorithm\r\n        </button>\r\n        <button className=\"top-buttons\" onClick={() => visualizeAstar(grid, startNode, finishNode)}>\r\n          Visualize A* Algorithm\r\n        </button>\r\n        <button className=\"top-buttons\" onClick={() => generateRandomMaze(startNode, finishNode)}>\r\n          Generate Random walls \r\n        </button>\r\n        \r\n        <button className=\"top-buttons\" onClick={() =>(setGrid(GridFactory.clearGrid(startNode, finishNode)))}>\r\n          Clear Grid \r\n        </button>\r\n        \r\n       \r\n        <div className=\"grid\" onMouseUp={() => handleMouseUp()}>\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {row, col, isFinish, isStart, isWall} = node;\r\n                  return (\r\n                  <Node\r\n                    key={nodeIdx}\r\n                    col={col}\r\n                    isFinish={isFinish}\r\n                    isStart={isStart}\r\n                    isWall={isWall}\r\n                    mouseIsPressed={isMousePressed}\r\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\r\n                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\r\n                    onMouseLeave={(row, col) => handleMouseLeave(row, col)}\r\n                    row={row}\r\n                  ></Node>\r\n                );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n    </Fragment>\r\n  );\r\n};\r\n\r\nexport default Grid;","import React from 'react';\r\nimport './App.css';\r\nimport Grid from './components/Grid.jsx'\r\n\r\nfunction App() {\r\n    return ( < div className = \"App\" >\r\n     <Grid/> \r\n      </div> );\r\n}\r\n\r\nexport default App;","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}